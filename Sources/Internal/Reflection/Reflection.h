#pragma once

#include <sstream>
#include "Base/Any.h"
#include "Base/AnyFn.h"
#include "Base/Type.h"
#include "Base/TypeInheritance.h"

#include "Debug/DVAssert.h"

#include "Reflection/ReflectedMeta.h"
#include "Reflection/ReflectedType.h"
#include "Reflection/ReflectedTypeDB.h"
#include "Reflection/ReflectedStructure.h"
#include "Reflection/ReflectedObject.h"

/** \defgroup reflection Reflection
    TODO: detailed description 
*/

/**
    \ingroup reflection
    TODO: usage comments
*/
#define DAVA_REFLECTION(Cls) IMPL__DAVA_REFLECTION(Cls)

/**
    \ingroup reflection
    TODO: usage comments
*/
#define DAVA_VIRTUAL_REFLECTION(Cls, ...) IMPL__DAVA_VIRTUAL_REFLECTION(Cls, ##__VA_ARGS__)

/**
    \ingroup reflection
    TODO: usage comments
*/
#define DAVA_REFLECTION_IMPL(Cls) IMPL__DAVA_REFLECTION_IMPL(Cls)

/**
    \ingroup reflection
    TODO: usage comments
*/
#define DAVA_REFLECTION_REGISTER_PERMANENT_NAME(Cls) IMPL__DAVA_REFLECTION_REGISTER_PERMANENT_NAME(Cls)

/**
    \ingroup reflection
    TODO: usage comments
*/
#define DAVA_REFLECTION_REGISTER_CUSTOM_PERMANENT_NAME(Cls, Name) IMPL__DAVA_REFLECTION_REGISTER_CUSTOM_PERMANENT_NAME(Cls, Name)

namespace DAVA
{
class ValueWrapper;
class StructureWrapper;

/**
    \ingroup reflection
    Must be used as base class for any user class that is going to have virtual reflection.

    \code
    class Foo : public DAVA::Reflection
    {
        DAVA_VIRTUAL_REFLECTION(Foo);
        // ...
    };
    \endcode
*/
struct ReflectionBase
{
    virtual ~ReflectionBase() = default;
    virtual const ReflectedType* GetReflectedType() const = 0;
};

/** 
    \ingroup reflection
    Holds reflected type information linked to appropriate runtime object.

    Reflection is created by linking any class or primitive data with its unique reflected type.
    Obtained Reflection allows to perform a number of operation over linked object:
    - get or set value from/to the object at runtime
    - introspect the object - its fields, methods, enumerations at runtime.
 
        +---------------+
        | ReflectedType |
        +---------------+

    It is also possible to create a new object or destroy existing objects from/with known reflected type.
*/
class Reflection final
{
public:
    struct Field;
    struct FieldCaps;
    struct Method;

    enum class CtorPolicy;

    Reflection() = default;
    Reflection(const Reflection&) = default;
    Reflection(const ReflectedObject& object, const ValueWrapper* vw, const StructureWrapper* sw, const ReflectedMeta* meta);

    bool IsValid() const;
    bool IsReadonly() const;

    const Type* GetValueType() const;
    ReflectedObject GetValueObject() const;

    Any GetValue() const;
    bool SetValue(const Any& value) const;
    bool SetValueWithCast(const Any& value) const;

    bool HasFields() const;
    Reflection GetField(const Any& name) const;
    Vector<Field> GetFields() const;

    bool HasMethods() const;
    AnyFn GetMethod(const String& key) const;
    Vector<Method> GetMethods() const;

    void Dump(std::ostream& out, size_t deep = 0) const;

    template <typename Meta>
    bool HasMeta() const;

    template <typename Meta>
    const Meta* GetMeta() const;

    template <typename T>
    static Reflection Create(T* objectPtr, const ReflectedMeta* objectMeta = nullptr);

    //
    // Experimental API for fields add/remove/insert create.
    // Is subject of change!
    //
    // -->
    //
    const FieldCaps& GetFieldsCaps() const;
    bool AddField(const Any& key, const Any& value) const;
    bool InsertField(const Any& beforeKey, const Any& key, const Any& value) const;
    bool RemoveField(const Any& key) const;
    AnyFn GetFieldCreator() const;

    static Reflection Create(const Any& any, const ReflectedMeta* objectMeta = nullptr);
    //
    // <--
    //

private:
    ReflectedObject object;
    const ValueWrapper* valueWrapper = nullptr;
    const StructureWrapper* structureWrapper = nullptr;
    const ReflectedMeta* meta = nullptr;
};

struct Reflection::Field
{
    Any key;
    Reflection ref;
};

struct Reflection::Method
{
    String key;
    AnyFn fn;
};

//
// Experimental API for fields add/remove/insert create.
// Is subject of change!
//
// -->
//
struct Reflection::FieldCaps
{
    bool canAddField = false;
    bool canInsertField = false;
    bool canRemoveField = false;
    bool canCreateFieldValue = false;
    bool hasAutogeneratedKeys = false;
    bool hasAutogeneratedValues = false;
    bool hasDynamicStruct = false;
    bool hasFlatStruct = false;
    const Type* flatKeysType = nullptr;
    const Type* flatValuesType = nullptr;
};
//
// <--
//

class ValueWrapper
{
public:
    ValueWrapper() = default;
    ValueWrapper(const ValueWrapper&) = delete;
    virtual ~ValueWrapper() = default;

    virtual const Type* GetType() const = 0;

    virtual bool IsReadonly(const ReflectedObject& object) const = 0;
    virtual Any GetValue(const ReflectedObject& object) const = 0;
    virtual bool SetValue(const ReflectedObject& object, const Any& value) const = 0;
    virtual bool SetValueWithCast(const ReflectedObject& object, const Any& value) const = 0;

    virtual ReflectedObject GetValueObject(const ReflectedObject& object) const = 0;
};

class EnumWrapper
{
    // TODO: implement
};

class StructureWrapper
{
public:
    StructureWrapper() = default;
    StructureWrapper(const StructureWrapper&) = delete;
    virtual ~StructureWrapper() = default;

    virtual bool HasFields(const ReflectedObject& object, const ValueWrapper* vw) const = 0;
    virtual Reflection GetField(const ReflectedObject& object, const ValueWrapper* vw, const Any& key) const = 0;
    virtual Vector<Reflection::Field> GetFields(const ReflectedObject& object, const ValueWrapper* vw) const = 0;

    virtual const Reflection::FieldCaps& GetFieldsCaps(const ReflectedObject& object, const ValueWrapper* vw) const = 0;

    virtual bool HasMethods(const ReflectedObject& object, const ValueWrapper* vw) const = 0;
    virtual AnyFn GetMethod(const ReflectedObject& object, const ValueWrapper* vw, const Any& key) const = 0;
    virtual Vector<Reflection::Method> GetMethods(const ReflectedObject& object, const ValueWrapper* vw) const = 0;

    virtual AnyFn GetFieldCreator(const ReflectedObject& object, const ValueWrapper* vw) const = 0;
    virtual bool AddField(const ReflectedObject& object, const ValueWrapper* vw, const Any& key, const Any& value) const = 0;
    virtual bool InsertField(const ReflectedObject& object, const ValueWrapper* vw, const Any& beforeKey, const Any& key, const Any& value) const = 0;
    virtual bool RemoveField(const ReflectedObject& object, const ValueWrapper* vw, const Any& key) const = 0;
};

template <typename T>
struct StructureWrapperCreator;

} // namespace DAVA

#define __DAVA_Reflection__
#include "Reflection/Private/Reflection_impl.h"
#include "Reflection/Private/ReflectedMeta_impl.h"
#include "Reflection/Private/ReflectedType_impl.h"
#include "Reflection/Private/ReflectedTypeDB_impl.h"
#include "Reflection/Private/ReflectedObject_impl.h"
